<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<section 
    xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xml:id="zend.module.module-class">
    <info>
        <title>The Module Class</title>
    </info>

    <para>
        By default, ZF2 module system simply expects each module name to be able to be resolved to
        an object instance. The default module resolver,
        <classname>Zend\Module\Listener\ModuleResolverListener</classname>, simply instantiates an
        instance of <classname>{moduleName}\Module</classname> for each enabled module.
    </para>

    <example xml:id="zend.module.module-class.example.minimal-module">
        <info>
            <title>A Minimal Module</title>
        </info>

        <para>
            As an example, provided the module name "MyModule",
            <classname>Zend\Module\Listener\ModuleResolverListener</classname> will simply expect
            the class <classname>MyModule\Module</classname> to be available. It relies on a
            registered autoloader, (typically <classname
                xlink:href="zend.module.module-autoloader">Zend\Loader\ModuleAutoloader</classname>)
            to find and include the <classname>MyModule\Module</classname> class if it is not
            already available. 
        </para>

        <para>
            A module named "MyModule" module might start out looking something like this:
        </para>
 
        <literallayout>
MyModule/
    Module.php
</literallayout>

        <para>
            Within <filename>Module.php</filename>, you define your
            <classname>MyModule\Module</classname> class:
        </para>

        <programlisting language="php"><![CDATA[
namespace MyModule;

class Module
{
}
]]></programlisting>
        <para>
            Though it will not serve any purpose at this point, this "MyModule" module now has
            everything it needs to be considered a valid module and be loaded by the module system!
        </para>
    </example>

    <para>
        This <classname>Module</classname> class serves as the single entry point for module manager
        listeners to interact with a module.  From within this simple, yet powerful class, modules
        can override or provide additional application configuration, perform initialization tasks
        such as registering autoloader(s) and event listeners, declaring dependencies, and much
        more.
    </para>

    <example xml:id="zend.module.module-class.example.typical-module-class">
        <info>
            <title>A Typical Module Class</title>
        </info>

        <para>
            The following example shows a more typical usage of the <classname>Module</classname>
            class:
        </para>

        <programlisting language="php"><![CDATA[
namespace MyModule;

use Zend\Module\Consumer\AutoloaderProvider;

class Module implements AutoloaderProvider
{
    public function getAutoloaderConfig()
    {
        return array(
            'Zend\Loader\ClassMapAutoloader' => array(
                __DIR__ . '/autoload_classmap.php',
            ),
            'Zend\Loader\StandardAutoloader' => array(
                'namespaces' => array(
                    __NAMESPACE__ => __DIR__ . '/src/' . __NAMESPACE__,
                ),
            ),
        );
    }

    public function getConfig()
    {
        return include __DIR__ . '/config/module.config.php';
    }
}
]]></programlisting>
    </example>    

    <para>
        For a list of the provided module manager listeners and the interfaces and methods that
        allow on <classname>Module</classname> classes, see the <link
            linkend="zend.module.module-manager.module-manager-listeners">module manager listeners
            documentation</link> and the <link
            linkend="zend.module.module-manager.module-manager-events">module mananger events
            documentation</link>.
    </para>

    <section xml:id="zend.module.module-class.the-loadModules.post-event">
        <info>
            <title>The "loadModules.post" Event</title>
        </info>

        <para>
            It is not safe for a module to assume that any other modules have already been loaded at
            the time <methodname>init()</methodname> method is called. If your module needs to
            perform any actions after all other modules have been loaded, the module manager's
            "loadModules.post" event makes this easy. 
        </para>

        <note>
            <para>
                For more information on methods like <methodname>init()</methodname> and
                <methodname>getConfig()</methodname>, refer to the <link
                    linkend="zend.module.module-manager.module-manager-listeners">module manager
                    listeners documentation</link>.
            </para>
        </note>

        <example xml:id="zend.module.module-class.example.loadModules.post-event">
            <info>
                <title>Sample Usage of "loadModules.post" Event</title>
            </info>

            <programlisting language="php"><![CDATA[
use Zend\EventManager\EventDescription as Event,
    Zend\Module\Manager as ModuleManager;

class Module
{
    public function init(ModuleManager $moduleManger)
    {
        // Remember to keep the init() method as lightweight as possible
        $events = $moduleManager->events();
        $events->attach('loadModules.post', array($this, 'modulesLoaded'));
    }

    public function modulesLoaded(Event $e)
    {
        // This method is called once all modules are loaded.
        $moduleManager = $e->getTarget();
        $loadedModules = $moduleManager->getLoadedModules();
        $config        = $moduleManager->getConfig();
    }
}
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.module.module-class.the-mvc-bootstrap-event">
        <info>
            <title>The MVC "bootstrap" Event</title>
        </info>

        <para>
            If you are writing an MVC-oriented module for ZF2, you may need access to additional
            parts of the application in your <classname>Module</classname> class such as the
            instance of <classname>Zend\Mvc\Application</classname> or its registered service
            locator/DI instance. For this, you may utilize the MVC "bootstrap" event. The bootstrap
            event is triggered after the "loadModule.post" event, once
            <code>$bootstrap->bootstrap($application)</code> is called.
        </para>

        <example xml:id="zend.module.module-class.example.mvc-bootstrap-event">
            <info>
                <title>Sample Usage of the MVC "bootstrap" Event</title>
            </info>

            <programlisting language="php"><![CDATA[
use Zend\EventManager\EventDescription as Event,
    Zend\EventManager\StaticEventManager;

class Module
{
    public function init()
    {
        // Remember to keep the init() method as lightweight as possible
        $events = StaticEventManager::getInstance();
        $events->attach('bootstrap', 'bootstrap', array($this, 'mvcBootstrap'));
    }

    public function mvcBootstrap(Event $e)
    {
        // This method is called once the MVC bootstrapping is complete
        $application = $e->getParam('application');
        $locator     = $application->getLocator();
    }
}
]]></programlisting>
        </example>
    </section>
</section>
